{"meta":{"title":"hamlog","subtitle":"hamlog","description":"서두르지 말고, 그러나 쉬지도 말고 - 괴테","author":"hamzzi","url":"https://harnzzi.github.io","root":"/"},"pages":[],"posts":[{"title":"Memento","slug":"Memento","date":"2020-05-31T11:47:55.000Z","updated":"2020-05-31T11:51:53.477Z","comments":true,"path":"2020/05/31/Memento/","link":"","permalink":"https://harnzzi.github.io/2020/05/31/Memento/","excerpt":"","text":"Memento Pattern의 취지와 목적은? Memento는 구현 세부 사항을 밝히지 않고 객체의 이전 상태를 저장하고 복원 할 수있는 행동 설계 패턴이다. 즉, private한 field들의 상태를 바꾸지 않고(public이나, protected 등..), 객체들에게 접근 용이하도록 만들기 위한 패턴이다. 다음의 예제를 보며 이해하도록 한다. Problem text editor 앱을 만들고 있다고 가정하자. 간단한 텍스트 편집 말고도, 텍스트의 format, image 삽입 등을 지원하도록 만들 것이다. 이후에, 유저가 자신이 text 편집기에서 수행한 작업을 다시 되돌릴 수 있도록 만들기로 결정했다. 이것의 구현을 위해서, 어떤 작업을 수행하기 전에 앱은 모든 object들의 상태를 저장하고, 그것을 storage에 저장하기로 했다. 이후에, 유저가 어떤 작업을 되돌리기로 결정했다면 앱은 최신 스냅샷을 가져온 후 이것을 이용해서 모든 object의 상태를 복원하도록 했다. 작업을 실행하기 전에 앱은 객체 상태의 스냅 샷을 저장하고 나중에 이 객체를 이전 상태로 복원하는 데 사용할 수 있다. 이러한 state snapshots는 어떻게 구현해야 할까? 아마도 모든 객체의 field를 살펴본 후, 그 값들을 storage에 저장해야 할 것이다. 그러나 이것은 object에 access 제한이 강력하지 않을 경우에만 작동할 것이다. 하지만 실제 구현에서는 object들은 다른 유저들이 쉽게 내부를 들여다 볼 수 없도록 하여 field의 중요한 data들을 모두 숨겨 버리기 때문에, 위처럼 구현하는 것은 좋지 않다. 하지만 지금은 그 문제를 무시하고, 모든 object의 field state가 public이며, open된 relations라고 생각해보자. 이러한 접근 방식은 즉시 현 문제를 해결 가능하며 object들의 snapshots를 생성할 수 있지만, 여전히 심각한 이슈가 존재한다. 나중에, 이 text editor class를 refactoring하거나, 일부 field를 추가하거나 제거하기로 한다면, 이 때 영향을 받는 object들의 state들을 복사하여 저장하는 클래스들을 변경해야 될 것이다. 여기서, 실제 어떤 text editor에서의 snapshots state를 고려해 본다면, 최소한 실제 텍스트, 커서 좌표, 현재 스크롤의 위치 등이 포함되어 있어야 할 것이다. 하나의 snapshot을 만들기 위해서는 이러한 값들을 모아서 어떠한 컨테이너에 넣어야 한다. 대부분의 경우, 이 object의 컨테이너를 이용해서 많은 text 저장 결과들을 기록해야 한다. 따라서 컨테이너는 한 클래스의 objects가 될 것이다. 이 클래스에는 method는 거의 없고, editor의 상태를 반영하는 많은 field가 존재하게 된다. 그리고 다른 objects가 snapshot에서 데이터를 읽고 쓰도록 하려면 아마 이 class의 field들을 모두 public state로 만들어야 한다. 결국 snapshot을 저장하기 위해서는 field들이 public이 되어야 한다. 다른 클래스는 snapshot 클래스의 아주 작은 변경에 dependency가 생기며, 그렇지 않으면 private field를 만드는 대신 외부 클래스에 영향을 미치지 않을 수 있지만, access가 제한되어 구현이 어렵게 된다. 실행 취소(undo)에 대한 다른 구현 방법이 존재할까? Solution 모든 문제는 결국 encapsulation이 깨져서 발생하게 되는 것이다. 일부 object들을 이용해서 어떤 작업을 수행할 때, 필요한 데이터를 수집하기 위해서 어떤 다른 object들의 private space를 침범해야하는 경우가 생길 수 있다. Memento Pattern은 snapshot 작성을 현재 상태의 실제 owner인 originator object에 맡긴다. 따라서 “외부”에서 editor의 상태를 복사하려는 다른 object 대신, editor class 자체가 자기 자신의 상태에 대해 모든 access 권한이 있으므로 snapshot을 만들 수 있게 된다. 즉, 이 패턴은 object state의 사본(copy)을 memento라고 불리는 어떤 특수한 object에 저장하도록 제안하는 것이다. memento의 content는 자기를 생성한 object를 제외한 다른 object에는 access할 수 없다. 다른 object들은 snapshot의 metadata(생성 시간, 수행한 작업의 이름 등..)를 가져올 수 있지만, snapshot에 포함되어 있는 원래 object들의 상태는 가져 올 수 없는 제한된 interface를 사용하여 커뮤니케이션 해야한다. originator는 memento에 대한 전체 access 권한을 가지지만, caretaker는 오직 metadata에만 access 가능하다. 이런 제한적인 정책을 이용하면 일반적으로 caretakers라고 불리는 objects에 memento를 저장할 수 있게 된다. caretaker는 제한된 interface를 통해서만 memento를 이용할 수 있으므로, memento 내부에 저장된 state를 조작할 수 없게 된다. 동시에 originator는 field에 모든 access를 지니고 있으므로 원하는대로 이전 상태로 field 값을 복원시킬 수 있다. text editor 예제에서, caretaker 역할을 하는 별도의 history class를 생성할 수 있다. Editor가 작업을 수행하려고 할 때 마다 caretaker 내부에 저장되어 있는 memento들의 stack이 늘어나게 된다. 앱의 UI에서 이 stack을 랜더링해서 이전에 수행했던 작업 기록을 유저에게 보여줄 수도 있게 된다. 사용자가 undo를 trigger하면, history는 stack에서 가장 최근의 memento를 가져 와서 편집기로 다시 전달한 후 roll-back을 요청한다. Editor는 memento에 대한 전체 access 권한을 가지므로 memento에서 가져온 값으로 자체 상태를 변경한다. Structure Implementation based on nested classes일반적인 구현은 중첩 클래스를 지원하는 것으로 한다. 즉, 다음 구현은 중첩된 클래스가 지원 가능한 언어에서만 가능하다 (C++, C#, Java, …). Originator 클래스는 자체 상태의 snapshot을 생성하고 필요할 때 snapshot에서 상태를 복원 할 수 있다.Memento는 originator의 state를 저장하는, 즉 snapshot 역할을하는 value object이다. Memento를 immutable하도록 만들고 생성자를 통해 데이터를 한 번만 전달하는 것이 일반적이다.Caretaker는 originator의 상태를 “언제”, 또 “왜” 캡쳐해야 하는지 알고있을 뿐 아니라 언제 state를 복원해야 하는 지도 알고 있어야 한다.Caretaker는 여러개의 memento의 stack을 저장함으로써 originator의 history를 추적할 수 있다. originator가 어떤 지점의 과거로 돌아갸아 할 경우, caretaker는 stack에서 최상위 memento를 가져와서 이를 originator의 restoration method에 전달한다.이 implementation에서, memento class는 originator에 중첩되어야 한다(nested). 이렇게 함으로써 memento의 field와 method가 private로 선언되어 있더라도 originator가 접근 가능하다. 반면에, caretaker는 memento의 field 및 method들에 제한적인 access를 갖고 있어 stack에 memento들을 저장하지만 상태를 변경할 수는 없게 된다. Implementation based on an intermediate interface 중첩 클래스를 지원하지 않는 프로그래밍 언어에 대한 적절한 대안법에 대해서 설명한다(PHP). 중첩 클래스가 없는 언어의 경우, 어떤 규칙을 설정함으로써 memento의 field의 access를 제한할 수 있다. 그 규칙이란 Caretaker가 오직 명시적으로 선언된(explicitly declared) intermediary interface를 통해서만 memento와 작업할 수 있으며, 이 interface는 오직 memento의 metadata와 관련된 method만 선언한다.반면에, originator는 memento class에 선언된 field와 method에게 access가 가능하여 memento object로 직접 작업할 수 있게 된다. 이 방법의 단점은 memento의 모든 멤버들을 public으로 선언해야 한다는 것이다. Implementation with even stricter encapsulation 다른 클래스가 memento를 통해서 originator의 상태에 access할 최소한의 가능성도 남기지 않기 위한 또 다른 구현법이 존재한다. 이 구현은 multiple type의 originator와 memento들을 가질 수 있다. 각 originator는 그에 대응하는 memento class와 동작한다. originator나 memento들은 그 누구에게도 자신의 state를 공개하지 않는다.Caretaker는 이제 memento들에 저장된 상태를 변경하지 못하도록 명시적으로 제한(explicitly restricted)된다. 또한 복원(restore)방법이 memento class에 정의되어 있기 때문에 caretaker class는 originator와 독립적(independent)인 관계를 갖게 된다.각 memento는 자신을 생성한 originator와 연결된다. originator는 자신의 state 값과, 자신 모두를 memento의 생성자에 전달한다. 이 class사이의 밀접한 관계 덕분에, memento는 originator에서 적절한 setter method가 정의되어 있다면 originator의 state를 복원할 수 있게 된다. Pseudocode 이 예제에서는, 복잡한 text editor 상태의 snapshot을 저장하고, 필요할 때 이 snapshot들에게서 이전 상태를 복원하기 위한 Command 패턴으로 memento 패턴을 사용한다. command object들은 caretaker 역할을 한다. command와 연관된 작업을 실행하기 전에, editor의 memento를 가져온다(fetch). 유저가 가장 최신의 command를 취소(undo)하고자 할 때 editor는 command에 저장된 memento를 사용해서 이전 상태로 되돌릴 수 있게 된다. memento class는 public field들, 또는 getter나 setter를 선언하지 않는다. 따라서 그 어떤 object라도 그 내용을 변경할 수 없게 된다. memento들은 그들을 생성한 editor object와 연결되어 있다. 이를 통해서, memento는 editor object의 setter를 통해서 데이터를 전달해서 링크된 editor의 상태를 복원할 수 있게 된다. memento는 특정 editor object에 연결되어 있으므로, 앱이 중앙 undo stack으로 독립적인 editor windows를 지원하도록 만들 수 있다. 원본 펼치기Applicability이전 상태의 object를 복원할 수 있도록 object의 상태에 대한 snapshot을 생성하려는 경우 이 패턴을 사용하면 좋을 것이다.memento 패턴을 사용하면, private field를 포함하여 object 상태의 전체 copy본을 만들고 object와 별개로 저장할 수 있게 된다. “undo” 사용 경우 말고도 트랜잭션(거래 처리 등)을 처리할 때도 필수적이다(즉, 오류가 나타날 시 작업을 roll back 해야하는 경우).object의 field/getter/setter에 대한 직접 access를 하는 경우가 encapsulation을 위반하는 경우 이 패턴을 사용하면 좋다.Memento는 object 자체의 상태 snapshot 생성을 책임진다. 다른 object는 snapshot을 읽을 수 없으므로 original object의 상태 데이터를 안전하게 보호할 수 있게 된다. How to Implement Determine what class will play the role of the originator. It’s important to know whether the program uses one central object of this type or multiple smaller ones. Create the memento class. One by one, declare a set of fields that mirror the fields declared inside the originator class. Make the memento class immutable. A memento should accept the data just once, via the constructor. The class should have no setters. If your programming language supports nested classes, nest the memento inside the originator. If not, extract a blank interface from the memento class and make all other objects use it to refer to the memento. You may add some metadata operations to the interface, but nothing that exposes the originator’s state. Add a method for producing mementos to the originator class. The originator should pass its state to the memento via one or multiple arguments of the memento’s constructor. The return type of the method should be of the interface you extracted in the previous step (assuming that you extracted it at all). Under the hood, the memento-producing method should work directly with the memento class. Add a method for restoring the originator’s state to its class. It should accept a memento object as an argument. If you extracted an interface in the previous step, make it the type of the parameter. In this case, you need to typecast the incoming object to the memento class, since the originator needs full access to that object. The caretaker, whether it represents a command object, a history, or something entirely different, should know when to request new mementos from the originator, how to store them and when to restore the originator with a particular memento. The link between caretakers and originators may be moved into the memento class. In this case, each memento must be connected to the originator that had created it. The restoration method would also move to the memento class. However, this would all make sense only if the memento class is nested into originator or the originator class provides sufficient setters for overriding its state. Pros and Cons |:—:|:—:||캡슐화를 위반하지 않고 객체 상태의 스냅 샷을 생성 할 수 있다.|클라이언트가 memento를 너무 자주 생성하게 된다면 앱에서 많은 RAM을 소비할 수 있게 된다.||Caretaker가 originator의 상태의 history를 유지하도록 하여 originator의 코드를 단순화 할 수 있다.|Caretaker는 사용하지 않는 memento를 destroy할 수 있도록 originator의 lifecycle을 추적해야 한다.|||PHP, Python 및 JS와 같은 대부분의 동적 프로그래밍 언어는 memento내의 상태가 그대로 유지되도록 보장할 수 없다.| Relations with Other Patterns Undo 구현 시 Command와 Memento를 함께 사용할 수 있다. 이 경우 Command는 target object에 대해 다양한 작업을 수행하는 반면에, Memento는 command가 실행되기 전에 해당 object의 상태를 저장한다.Iterator와 함께 Memento를 사용하여 현재 iteration state를 캡처한 후 필요한 경우 roll back할 수 있다.때때로 프로토타입은 memento의 간단한 대안점이 될 수 있다. 이는 history에서 저장하고자 하는 상태인 object가 상당히 간단하고, 외부 자원(external resources)과 연결된 것이 없거나 또는 link를 재설정(re-establish)하기 쉬운 경우에 작동한다.","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"https://harnzzi.github.io/categories/Design-Patterns/"},{"name":"Behavioral Patterns","slug":"Design-Patterns/Behavioral-Patterns","permalink":"https://harnzzi.github.io/categories/Design-Patterns/Behavioral-Patterns/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"https://harnzzi.github.io/tags/Design-Patterns/"},{"name":"Memento","slug":"Memento","permalink":"https://harnzzi.github.io/tags/Memento/"}]},{"title":"메모리 구조 이해하기","slug":"메모리-구조-이해하기","date":"2020-04-19T14:33:31.000Z","updated":"2020-04-19T14:33:31.096Z","comments":true,"path":"2020/04/19/메모리-구조-이해하기/","link":"","permalink":"https://harnzzi.github.io/2020/04/19/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"BOJ::9207{페그솔테리어};","slug":"BOJ-9207-페그솔테리어","date":"2020-04-19T12:03:09.000Z","updated":"2020-04-19T14:11:16.356Z","comments":true,"path":"2020/04/19/BOJ-9207-페그솔테리어/","link":"","permalink":"https://harnzzi.github.io/2020/04/19/BOJ-9207-%ED%8E%98%EA%B7%B8%EC%86%94%ED%85%8C%EB%A6%AC%EC%96%B4/","excerpt":"","text":"Infomation o: 핀이 꽂혀있는 칸 #: 구멍이 없는 칸 .: 빈 칸핀의 개수는 최대 8개이며(작은 수로 백트래킹이 가능해 보임),핀은 수평이나 수직 방향으로 인접한 핀을 뛰어 넘어서 그 핀의 다음 칸으로 이동하는 것만 허용된다.인접한 핀의 다음 칸은 비어있어야 하며, 인접한 핀은 제거된다. Idea map의 정보와, 이동 횟수(depth)를 parameter로 갖고 백트래킹을 구현한다. map을 순차적으로 탐색하다가, o를 발견하면 움직일 수 있는 칸이 있는지 확인하고 움직일 수 있다면 이동한 후, 이동한 map의 정보와 depth를 1 추가하고 재귀로 해당 함수를 다시 수행한다. 더이상 이동할 수 없다면, 이동했던 핀을 다시 원래대로 돌려놓고, 다른 핀을 찾기 위해 map을 탐색한다. 이동할 수 있는 다른 핀을 찾게 된다면, 다시 3번으로 돌아가 반복하여 수행한다. 위 과정을 수행하는 도중에 현재 핀의 개수가 최소 개수일 때, 최소값과 depth를 갱신한다. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;using namespace std;char map[5][9];int t, Min = 1e9, Cnt;int dx[4] = &#123; -1,1,0,0 &#125;;int dy[4] = &#123; 0,0,-1,1 &#125;;bool IsRange(int x, int y)&#123; return (x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; 5 &amp;&amp; y &lt; 9);&#125;void BackTracking(char map[5][9], int depth = 0)&#123; int Cur = 0; for (int i = 0; i &lt; 5; ++i) &#123; for (int j = 0; j &lt; 9; ++j) &#123; if (map[i][j] == 'o') &#123; Cur = Cur + 1; &#125; &#125; &#125; if (Cur &lt; Min) &#123; Min = Cur; Cnt = depth; &#125; for (int x = 0; x &lt; 5; ++x) &#123; for (int y = 0; y &lt; 9; ++y) &#123; if (map[x][y] == 'o') &#123; for (int d = 0; d &lt; 4; ++d) &#123; int nx = x + dx[d]; int ny = y + dy[d]; int jx = nx + dx[d]; //jump x int jy = ny + dy[d]; //jump y if (IsRange(nx, ny) &amp;&amp; IsRange(jx, jy) &amp;&amp; map[nx][ny] == 'o' &amp;&amp; map[jx][jy] == '.') &#123; map[x][y] = '.'; map[nx][ny] = '.'; map[jx][jy] = 'o'; BackTracking(map, depth + 1); map[x][y] = 'o'; map[nx][ny] = 'o'; map[jx][jy] = '.'; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; ios_base::sync_with_stdio(false); cin &gt;&gt; t; while (t--) &#123; for (int i = 0; i &lt; 5; ++i) &#123; for (int j = 0; j &lt; 9; ++j) &#123; cin &gt;&gt; map[i][j]; &#125; &#125; BackTracking(map); cout &lt;&lt; Min &lt;&lt;\" \"&lt;&lt; Cnt &lt;&lt; \"\\n\"; Min = 1e9; Cnt = 0; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://harnzzi.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://harnzzi.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://harnzzi.github.io/tags/BOJ/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://harnzzi.github.io/tags/Algorithm/"}]},{"title":"std::vector에서 size, capacity의 차이점은 무엇일까?","slug":"std-vector에서-size-capacity의-차이점은-무엇일까","date":"2020-04-19T10:36:55.000Z","updated":"2020-04-19T11:34:20.555Z","comments":true,"path":"2020/04/19/std-vector에서-size-capacity의-차이점은-무엇일까/","link":"","permalink":"https://harnzzi.github.io/2020/04/19/std-vector%EC%97%90%EC%84%9C-size-capacity%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/","excerpt":"","text":"std::vector, std::string에서는 길이 리턴이 가능하다. string에서는 length, size모두 사용 가능하며, vector에서는 size를 사용하면 되겠다. 그런데 갑자기 인텔리센스(자도완성)에서 보이는 capacity… size와 차이가 무엇일까? size와 capacity 위 그림과 같이, capacity는 vector의 type 또는 string의 각 character type들을 담을 수 있는 메모리가 할당되어 있는 공간의 용량이다. 보통, capacity는 현재 가지고 있는 원소의 개수(size, length)보다 더 많은 공간을 할당해 놓고 있다. 일반적으로 string에서는 8bytes를 미리 확보하고, 그보다 length가 더 길다면 32bytes, … 순으로 증가하는 것으로 보인다(이는 컴퓨터 구조, os등에 따라 차이가 보여질 수 있다). 따라서, 새로운 원소를 추가할 때(push_back) capacity가 size보다 크다면, O(1)로 새로운 원소를 추가하거나 지울 수 있게 된다. 하지만 할당한 공간(capacity)를 다 채우게 되면 새로운 연속된 공간을 다시 할당하여 기존의 원소들을 모두 복사해야 한다. 결국 O(n)으로 수행된다. 즉, 새로운 원소를 추가할 때 capacity &gt; size맨 뒤 공간에 원소를 복사한 뒤 ++size만 일어난다. (O(1)) capacity == sizecapacity가 증가한 새로운 연속된 공간을 할당하고, 기존의 원소를 모두 복사하고 기존 정보는 지운다. capacity &gt; size인 상황으로 만든 후 1번 과정을 다시 진행한다. (O(n)) resize와 reserve 위에서 보았듯이, reserve에서는 capacity를 우리가 원하는 크기로 할당 가능하게 한다. resize는 원하는 수 만큼 원소를 생성한다. 또한 증가되는 size만큼 복사 생성자가 호출된다는 점이 있다(In c++11). example 12345678910111213141516#include &lt;iostream&gt;#include &lt;string&gt;void* operator new(std::size_t count) &#123; std::cout &lt;&lt; count &lt;&lt; \" bytes 할당\" &lt;&lt; std::endl; return malloc(count);&#125;bool contains_easy(const std::string&amp; str) &#123; return str.find(\"easy\") != std::string::npos;&#125;int main() &#123; std::cout &lt;&lt; contains_easy(\"Test word\") &lt;&lt; std::endl; std::cout &lt;&lt; contains_easy(\"c++ string is not easy to use\") &lt;&lt; std::endl;&#125; 위의 예제에서 “Test word”와 “c++ string is not easy to use”에서 출력되는 결과는 다음과 같다. 123458 bytes 할당08 bytes 할당32 bytes 할당1 실제로 8bytes를 기본으로 capacity로 할당하고 있으나, 그 이상으로 string의 size가 넘어갈 시에 32bytes로 재할당시키는 것을 볼 수 있다. Reference https://en.cppreference.com/w/cpp/container/vector/capacity https://en.cppreference.com/w/cpp/container/vector/size","categories":[{"name":"C++","slug":"C","permalink":"https://harnzzi.github.io/categories/C/"}],"tags":[{"name":"C++11","slug":"C-11","permalink":"https://harnzzi.github.io/tags/C-11/"},{"name":"standard","slug":"standard","permalink":"https://harnzzi.github.io/tags/standard/"},{"name":"--c++11","slug":"c-11","permalink":"https://harnzzi.github.io/tags/c-11/"}]},{"title":"Hello World using Hexo!","slug":"hello-world","date":"2020-04-19T08:37:19.795Z","updated":"2020-04-19T08:57:09.371Z","comments":true,"path":"2020/04/19/hello-world/","link":"","permalink":"https://harnzzi.github.io/2020/04/19/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy or 12$ hexo d -g # hexo deploy --generate$ hexo g -d # hexo generate --deploy More info: Deployment Update12$ hexo clean$ hexo g -d Posting1$ hexo new post &lt;post_name&gt;","categories":[{"name":"Web","slug":"Web","permalink":"https://harnzzi.github.io/categories/Web/"},{"name":"FrameWork","slug":"Web/FrameWork","permalink":"https://harnzzi.github.io/categories/Web/FrameWork/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://harnzzi.github.io/tags/Web/"},{"name":"Blog","slug":"Blog","permalink":"https://harnzzi.github.io/tags/Blog/"},{"name":"Hexo","slug":"Hexo","permalink":"https://harnzzi.github.io/tags/Hexo/"}]},{"title":"BOJ::17825{주사위윷놀이};","slug":"BOJ-17825-주사위윷놀이","date":"2020-04-17T13:25:52.000Z","updated":"2020-04-19T08:58:16.619Z","comments":true,"path":"2020/04/17/BOJ-17825-주사위윷놀이/","link":"","permalink":"https://harnzzi.github.io/2020/04/17/BOJ-17825-%EC%A3%BC%EC%82%AC%EC%9C%84%EC%9C%B7%EB%86%80%EC%9D%B4/","excerpt":"","text":"Infomation 처음에는 시작 칸에 말 4개가 있다. 말은 게임판에 그려진 화살표의 방향대로만 이동할 수 있다. 말이 파란색 칸에서 이동을 시작하면 파란색 화살표를 타야 하고, 이동하는 도중이거나 파란색이 아닌 칸에서 이동을 시작하면 빨간색 화살표를 타야 한다. 말이 도착 칸으로 이동하면 주사위에 나온 수와 관계 없이 이동을 마친다. 게임은 10개의 턴으로 이루어진다. 매 턴마다 1부터 5까지 한 면에 하나씩 적혀있는 5면체 주사위를 굴리고, 도착 칸에 있지 않은 말을 하나 골라 주사위에 나온 수만큼 이동시킨다. 말이 이동을 마치는 칸에 다른 말이 있으면 그 말은 고를 수 없다. 단, 이동을 마치는 칸이 도착 칸이면 고를 수 있다 말이 이동을 마칠 때마다 칸에 적혀있는 수가 점수에 추가된다. Idea 입력받는 10개의 수는 주사위가 순서대로 주어지는 것이므로, 순서대로 주어지는 주사위 값을 4개의 말 중 하나와 대응하면 될 것이다. 모든 경우의 수는 4^10 = 1,048,576 번이므로, 시간복잡도가 높지만 문제가 될 것 같지 않다. 각 주사위 수에 말을 대입하면서 다음과 같은 경우에는 조합을 건너뛴다. 현재의 말이 이미 도착한 경우 말이 이동을 완료한 후 위치에 다른 말이 존재할 경우 조합이 완료되었다면, 점수를 그 전의 점수와 비교하여 더 큰 값으로 갱신한다. Design 말의 구조체를 생성한다. 구조체에는 말이 현재 존재하고있는 위치와, 이미 도착 칸에 있는지에 대한 정보가 있어야 한다. 말판에 대한 배열이 생성되어야 한다. 말판이 blue일 때와","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://harnzzi.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://harnzzi.github.io/categories/Algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://harnzzi.github.io/tags/BOJ/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://harnzzi.github.io/tags/Algorithm/"}]},{"title":"Linux Kernel에 대하여...(수정중)","slug":"Linux-Kernel에-대하여","date":"2020-03-18T12:53:56.000Z","updated":"2020-04-19T12:01:13.601Z","comments":true,"path":"2020/03/18/Linux-Kernel에-대하여/","link":"","permalink":"https://harnzzi.github.io/2020/03/18/Linux-Kernel%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC/","excerpt":"","text":"커널은 부팅 시에 시작되어 컴퓨터 종료시 커널이 끝난다. 장치 드라이버는 하드웨어와 밀접하게 연관되고 해당 장치를 제어하는 프로그램이다. 커널 공간에서 이루어지는 작업으로는 입출력, 네트워크 등의 하드웨어 제어, 메모리와 같은 컴퓨터의 리소스 관리, 응용 프로그램의 실행 제어 등이 있다. 커널과는 달리 응용 프로그램은 사용자 요청에 의해 저장장치로부터 메모리에 로드되어 실행한다. 응용 프로그램이 하드웨어를 직접 제어할 수는 없기 때문에, 커널의 장치 드라이버를 사용하기 위해 시스템 호출 방법으로 커널에 접근하여 자료를 처리한다. 전자 제품에서 각각의 주변 기기들을 제어하기 위해 설계된 펌웨어 또한 장치 드라이버로 분류된다. 장치 드라이버의 실제 예는 소스가 공개된 리눅스 커널 소스에서 /driver 디렉터리 밑에 있는 파일들을 참조하여 볼 수 있다. Reference https://ko.wikipedia.org/wiki/%EC%8B%9C%EC%8A%A4%ED%85%9C_%ED%98%B8%EC%B6%9C","categories":[{"name":"Operating System","slug":"Operating-System","permalink":"https://harnzzi.github.io/categories/Operating-System/"}],"tags":[{"name":"OS","slug":"OS","permalink":"https://harnzzi.github.io/tags/OS/"},{"name":"Linux","slug":"Linux","permalink":"https://harnzzi.github.io/tags/Linux/"},{"name":"Kernel","slug":"Kernel","permalink":"https://harnzzi.github.io/tags/Kernel/"}]},{"title":"RTOS와 GTOS <스케쥴링> 편","slug":"RTOS와-GTOS-스케쥴링-편","date":"2020-02-24T15:46:02.000Z","updated":"2020-04-19T08:59:32.657Z","comments":true,"path":"2020/02/25/RTOS와-GTOS-스케쥴링-편/","link":"","permalink":"https://harnzzi.github.io/2020/02/25/RTOS%EC%99%80-GTOS-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81-%ED%8E%B8/","excerpt":"RTOS(Real Time Operating System)과, 일반적으로 OS라고 불리우는 GPOS(General Purpose Operating System)에 대해서 알아봅니다. RTOS GPOS 우선순위 기반 스케쥴링 우선순위 보다는 스레드와 프로세스 모두 동일한 순서로 수행. 즉, 높은 스루풋을 기준으로 처리 프로그램이 실행되는 시간이 중요한 시스템에 적합 동시에 많은 응용 프로그램을 실행하기에 좋음. 우선순위가 높은 하나의 작업을 해야하는 프로세스가 있다고 하더라도, 우선순위가 낮은 여러개의 작업을 먼저 수행할 수 있음(preemptive/non-preemptive) 항상 우선순위를 기반으로 하고(preemptive), 우선순위가 높은 프로세스를 실행할 때 동안 낮은 우선순위를 가진 프로세스는 실행되지 않음 OS는 스케쥴링된 스레드가 많을수록 latency가 생길 수 있는데, RTOS의 경우 프로세스와 스레드가 모두 지정된 시간 제한 내에 실행되어야 하기 때문에 latency가 없음","text":"RTOS(Real Time Operating System)과, 일반적으로 OS라고 불리우는 GPOS(General Purpose Operating System)에 대해서 알아봅니다. RTOS GPOS 우선순위 기반 스케쥴링 우선순위 보다는 스레드와 프로세스 모두 동일한 순서로 수행. 즉, 높은 스루풋을 기준으로 처리 프로그램이 실행되는 시간이 중요한 시스템에 적합 동시에 많은 응용 프로그램을 실행하기에 좋음. 우선순위가 높은 하나의 작업을 해야하는 프로세스가 있다고 하더라도, 우선순위가 낮은 여러개의 작업을 먼저 수행할 수 있음(preemptive/non-preemptive) 항상 우선순위를 기반으로 하고(preemptive), 우선순위가 높은 프로세스를 실행할 때 동안 낮은 우선순위를 가진 프로세스는 실행되지 않음 OS는 스케쥴링된 스레드가 많을수록 latency가 생길 수 있는데, RTOS의 경우 프로세스와 스레드가 모두 지정된 시간 제한 내에 실행되어야 하기 때문에 latency가 없음 Foreground/Background system 복잡도가 낮은 소형 시스템은 일반적으로 전경/배경 시스템, 또는 super-loop로 설계됩니다. super-loop는 각 모듈을 호출하여 원하는 작업(함수)을 수행하는 무한루프(while(1))로 구성되어 있으며, 이것을 배경(Background) 시스템이라 부릅니다. 인터럽트 서비스 루틴(ISR)은 비동기 이벤트들(Foreground)를 처리합니다. 즉, Background에서 작업을 수행하다가 꼭 필요한 시기에 우선순위가 높은 작업을 수행해 주어야 한다면 Foreground; ISR(Interrupt Service Routine)를 처리하게 됩니다. 따라서 위의 그림과 같이, Background가 작업을 수행하다가 인터럽트가 걸리게 되면 멈추고 인터럽트부터 처리합니다(꼭!). 그 이후에야 Background로 복귀가 가능합니다. Pros and Cons 간단한 프로그램 짜기에 용이합니다. 커널에 의한 메모리손실이나 수행시간 손실이 없습니다. 모든 함수는 우선순위가 같기 때문에, 프로그래머 자신이 순서대로 잘 돌 수 있도록 코드를 짜는 것이 중요합니다. Real-Time Kernel System 커널기반의 프로그램을 이용하면 위의 Background/Foreground system과 다음과 같은 차이점이 존재합니다. 커널을 사용하게 되면, 2.5%정도의 시간을 더 허비하게 됩니다 커널 사용시 ROM, RAM을 더 많이 사용하게 됩니다. Real-Time Kernel은 MCU의 수행 시간을 컨트롤합니다. 즉, 제일 우선순위가 높은 것 부터 처리할 수 있습니다. 한 프로그램에 여러개의 Task가 존재합니다. (즉, 무한루프가 여러개 존재합니다.) 각각의 Task들은 자기 자신이 온전히 CPU를 독점하여 사용하는 것 처럼 동작합니다. (1) 우선 순위가 낮은 작업이 실행 중입니다. (2) 인터럽트가 발생하면, CPU는 인터럽트 서비스를 담당하는 ISR로 벡터(Array);다수의 데이터를 처리하는 명령어를 가진 CPU ㅡ 를 보냅니다. (3) ISR은 인터럽트 장치를 서비스 하지만 실제로는 거의 작동하지 않습니다. ISR은 일반적으로 높은 우선 순위를 가진 작업에 신호를 보내거나 메시지를 보냅니다. (4) ISR이 완료되면 높은 우선순위를 가진 Task를 수행 할 준비가 되었으며, 그 전 중단된 낮은 우선순위의 작업으로 돌아가지 않고 대신 더 중요한 작업으로 Context Switch됩니다. (5) 우선 순위가 높은 작업은 인터럽트에 응답하여 필요한 처리를 실행하고 수행합니다. (6) 우선순위가 높은 작업이 완료되면 Task의 시작 부분으로 돌아갑니다. (7) 낮은 우선순위를 갖고 있던 작업은 인터럽트 되었던 지점에서부터 정확하게 다시 시작합니다. 즉, Background/Foreground System은 모든 일을 수행하는 순서와 끝내는 시간, 그 종류 등을 모두 직접 계산하고 결정해야 합니다. 하지만 Kernel System을 이용하면 해야할 작업의 우선순위를 지정한다면 그것을 알아서 진행시킬 수 있다는 이점이 있습니다. Context Switching 커널의 스케쥴러가 각 Task를 수행하는 작업을 하게 됩니다. 이 때 원칙에 따라 커널의 종류가 선점형(preemptive)과 비선점형(non-preemptive)로 나뉘게 됩니다. 이 때 Context Switching이 빠른 커널이 꼭 장점만 있는 것은 아닙니다. 왜냐하면, CPU가 가지고 있는 레지스터의 양에 따라서 부과되는 오버헤드의 양이 달라지기 때문입니다. 즉, Context Switching이 Kernel Dependent하면서도 CPU Dependent하므로 이것만으로 커널의 성능을 결정 지을 수는 없게 됩니다. 또한 각각의 Task들은 선언되어 컴파일 되는 순간 스택에 자신의 공간을 갖습니다. 이 때 레지스터 정보를 스택에 Push하고, 수행할 Task의 레지스터 정보를 Pop하여 일을 수행합니다. 이후에 Context Switching을 해야할 때 다시 현재의 레지스터 정보를 스택에 저장하고, 빼내어 수행하는 일을 매우 빠르고 효율적으로 수행하면서 멀티 태스킹을 하게 됩니다. Non-preemptive v.s Preemptive 비선점형 커널은 ISR로 바로 넘겨주기 전에 돌고 있던 Task로 다시 CPU 점유권을 넘기는 커널입니다. 따라서 아무리 우선순위가 높은 Task가 점유하고자 해도 현재 작업을 수행하고 있는 Task에게 CPU 점유권이 주어집니다. 따라서 이러한 커널은 멀티태스킹을 하기 위해서, Task가 자체적으로 자신의 CPU 점유권을 놓아야 합니다. ex) OS_Dly_wait(100)… 따라서 다음과 같은 특징이 존재하게 됩니다. 인터럽트의 지연시간이 짧습니다(응답시간과 복귀시간이 짧아지게 됩니다). Task레벨에서도 비재진입 함수를 사용할 수 있게 됩니다(Task에서 제어권을 넘겨주기 전에는 절대로 다른 Task로 제어권이 넘어가지 않기 때문). Task의 응답성이 떨어집니다(수행시간이 긴 Task가 점유하게 된다면, 우선순위가 높은 Task가 오랜시간 동안 대기해야 될 가능성). 선점형 커널은 이와 반대로, ISR에서 복귀할 때 최 우선순위를 갖는 Task에게 CPU 점유율을 넘기게 됩니다. 따라서 로직이 조금 더 복잡하지만, 프로그램의 응답성이 매우 개선됩니다. 선점형 커널에서는 최상위 우선순위 Task가 언제 CPU를 받을 수 있을지 알 수 있게 되는데, 그로 인하여 Critical Section, 비재진입 함수의 사용 등에서 문제가 발생하게 됩니다. 아직 Task의 작업이 끝나지 않은 상태에서 더 중요한 Task에 CPU 점유권이 넘어갔는데 비재진입 함수를 호출한다면 데이터가 꼬이게 될 가능성이 존재하게 됩니다(전역변수, …). 따라서 상호 배제적으로 공유자원에 접근하기 위한 방법이 필요하게 됩니다. 그 방법은 다음과 같습니다. 인터럽트 enable/disable Semaphore의 사용 TAS(Test and Set) Scheduler Lock/Unlcok Clock Tick, Jitter Clock Tick이란 정기적으로 일어나는 특별한 인터럽트입니다. Clock Tick을 통하여 CPU의 점유권을 스케쥴러에게 양도하고, 지정한 틱이 지나면 Ready List에 들어가게 됩니다. 하지만 위와 같이 높은 우선순위의 Task와 ISR이 1틱(20ms)만큼 딜레이 하려는 Task보다 선행되어 실행되는 경우, 실제로는 불규칙적인 간격을 보이게 됩니다. 이러한 현상을 Jitter라고 합니다. 따라서 Jitter현상은 Hard Real-Time OS에서 조금 덜한 현상을 보입니다. Reference https://doc.micrium.com/ http://www.circuitstoday.com/gpos-versus-rtos-for-an-embedded-system ‘Operating Systems : Three Easy Pieces’, Remzi H. Arpaci-Dusseau, Andrea C. Arpaci-dusseau","categories":[{"name":"Operating System","slug":"Operating-System","permalink":"https://harnzzi.github.io/categories/Operating-System/"},{"name":"RTOS","slug":"Operating-System/RTOS","permalink":"https://harnzzi.github.io/categories/Operating-System/RTOS/"}],"tags":[{"name":"OS","slug":"OS","permalink":"https://harnzzi.github.io/tags/OS/"},{"name":"RTOS","slug":"RTOS","permalink":"https://harnzzi.github.io/tags/RTOS/"},{"name":"GPOS","slug":"GPOS","permalink":"https://harnzzi.github.io/tags/GPOS/"},{"name":"Scheduling","slug":"Scheduling","permalink":"https://harnzzi.github.io/tags/Scheduling/"}]}],"categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"https://harnzzi.github.io/categories/Design-Patterns/"},{"name":"Behavioral Patterns","slug":"Design-Patterns/Behavioral-Patterns","permalink":"https://harnzzi.github.io/categories/Design-Patterns/Behavioral-Patterns/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://harnzzi.github.io/categories/Algorithm/"},{"name":"BOJ","slug":"Algorithm/BOJ","permalink":"https://harnzzi.github.io/categories/Algorithm/BOJ/"},{"name":"C++","slug":"C","permalink":"https://harnzzi.github.io/categories/C/"},{"name":"Web","slug":"Web","permalink":"https://harnzzi.github.io/categories/Web/"},{"name":"FrameWork","slug":"Web/FrameWork","permalink":"https://harnzzi.github.io/categories/Web/FrameWork/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://harnzzi.github.io/categories/Operating-System/"},{"name":"RTOS","slug":"Operating-System/RTOS","permalink":"https://harnzzi.github.io/categories/Operating-System/RTOS/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"https://harnzzi.github.io/tags/Design-Patterns/"},{"name":"Memento","slug":"Memento","permalink":"https://harnzzi.github.io/tags/Memento/"},{"name":"BOJ","slug":"BOJ","permalink":"https://harnzzi.github.io/tags/BOJ/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://harnzzi.github.io/tags/Algorithm/"},{"name":"C++11","slug":"C-11","permalink":"https://harnzzi.github.io/tags/C-11/"},{"name":"standard","slug":"standard","permalink":"https://harnzzi.github.io/tags/standard/"},{"name":"--c++11","slug":"c-11","permalink":"https://harnzzi.github.io/tags/c-11/"},{"name":"Web","slug":"Web","permalink":"https://harnzzi.github.io/tags/Web/"},{"name":"Blog","slug":"Blog","permalink":"https://harnzzi.github.io/tags/Blog/"},{"name":"Hexo","slug":"Hexo","permalink":"https://harnzzi.github.io/tags/Hexo/"},{"name":"OS","slug":"OS","permalink":"https://harnzzi.github.io/tags/OS/"},{"name":"Linux","slug":"Linux","permalink":"https://harnzzi.github.io/tags/Linux/"},{"name":"Kernel","slug":"Kernel","permalink":"https://harnzzi.github.io/tags/Kernel/"},{"name":"RTOS","slug":"RTOS","permalink":"https://harnzzi.github.io/tags/RTOS/"},{"name":"GPOS","slug":"GPOS","permalink":"https://harnzzi.github.io/tags/GPOS/"},{"name":"Scheduling","slug":"Scheduling","permalink":"https://harnzzi.github.io/tags/Scheduling/"}]}