<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>hamlog</title>
    <link>https://harnzzi.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>서두르지 말고, 그러나 쉬지도 말고 - 괴테</description>
    <pubDate>Sun, 19 Apr 2020 12:04:35 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>BOJ::9207{페그솔테리어};</title>
      <link>https://harnzzi.github.io/2020/04/19/BOJ-9207-%ED%8E%98%EA%B7%B8%EC%86%94%ED%85%8C%EB%A6%AC%EC%96%B4/</link>
      <guid>https://harnzzi.github.io/2020/04/19/BOJ-9207-%ED%8E%98%EA%B7%B8%EC%86%94%ED%85%8C%EB%A6%AC%EC%96%B4/</guid>
      <pubDate>Sun, 19 Apr 2020 12:03:09 GMT</pubDate>
      <description>
      
      </description>
      
      
      <comments>https://harnzzi.github.io/2020/04/19/BOJ-9207-%ED%8E%98%EA%B7%B8%EC%86%94%ED%85%8C%EB%A6%AC%EC%96%B4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>std::vector에서 size, capacity의 차이점은 무엇일까?</title>
      <link>https://harnzzi.github.io/2020/04/19/std-vector%EC%97%90%EC%84%9C-size-capacity%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/</link>
      <guid>https://harnzzi.github.io/2020/04/19/std-vector%EC%97%90%EC%84%9C-size-capacity%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/</guid>
      <pubDate>Sun, 19 Apr 2020 10:36:55 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt; std::vector, std::string에서는 길이 리턴이 가능하다. string에서는 length, size모두 사용 가능하며, vector에서는 size를 사용하면 되겠다. 그런데 갑자기 인텔리센스(자도완성)에서 보이는 capacity…
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p> std::vector, std::string에서는 길이 리턴이 가능하다. string에서는 length, size모두 사용 가능하며, vector에서는 size를 사용하면 되겠다. 그런데 갑자기 인텔리센스(자도완성)에서 보이는 capacity… size와 차이가 무엇일까?</p><hr><h1 id="size와-capacity"><a href="#size와-capacity" class="headerlink" title="size와 capacity"></a>size와 capacity</h1><p> <img src="https://raw.githubusercontent.com/harnzzi/harnzzi.github.io/master/2020/04/19/std-vector%EC%97%90%EC%84%9C-size-capacity%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/1.PNG" alt="size and capacity"><br> 위 그림과 같이, capacity는 vector의 type 또는 string의 각 character type들을 담을 수 있는 메모리가 할당되어 있는 공간의 용량이다. <br>보통, capacity는 현재 가지고 있는 원소의 개수(size, length)보다 더 많은 공간을 할당해 놓고 있다.<br> 일반적으로 string에서는 8bytes를 미리 확보하고, 그보다 length가 더 길다면 32bytes, … 순으로 증가하는 것으로 보인다(이는 컴퓨터 구조, os등에 따라 차이가 보여질 수 있다). <br><br>따라서, 새로운 원소를 추가할 때(push_back) capacity가 size보다 크다면, <em>O(1)</em>로 새로운 원소를 추가하거나 지울 수 있게 된다. <br><br><br>하지만 할당한 공간(capacity)를 다 채우게 되면 새로운 연속된 공간을 다시 할당하여 기존의 원소들을 모두 복사해야 한다. 결국 <em>O(n)</em>으로 수행된다. </p><hr><p> 즉, 새로운 원소를 추가할 때</p><ol><li><strong>capacity &gt; size</strong><br>맨 뒤 공간에 원소를 복사한 뒤 ++size만 일어난다. (<em>O(1)</em>)</li><li><strong>capacity == size</strong><br>capacity가 증가한 새로운 연속된 공간을 할당하고, 기존의 원소를 모두 복사하고 기존 정보는 지운다. capacity &gt; size인 상황으로 만든 후 1번 과정을 다시 진행한다. (<em>O(n)</em>)</li></ol><hr><h1 id="resize와-reserve"><a href="#resize와-reserve" class="headerlink" title="resize와 reserve"></a>resize와 reserve</h1><p> 위에서 보았듯이, <strong>reserve</strong>에서는 capacity를 우리가 원하는 크기로 할당 가능하게 한다. <br><br> <strong>resize</strong>는 원하는 수 만큼 원소를 생성한다. 또한 증가되는 size만큼 복사 생성자가 호출된다는 점이 있다(In c++11). </p><h1 id="example"><a href="#example" class="headerlink" title="example"></a>example</h1> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> count)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="string">" bytes 할당"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">malloc</span>(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">contains_easy</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> str.<span class="built_in">find</span>(<span class="string">"easy"</span>) != <span class="built_in">std</span>::<span class="built_in">string</span>::npos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; contains_easy(<span class="string">"Test word"</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; contains_easy(<span class="string">"c++ string is not easy to use"</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 위의 예제에서 “Test word”와 “c++ string is not easy to use”에서 출력되는 결과는 다음과 같다.</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">8 bytes 할당</span><br><span class="line">0</span><br><span class="line">8 bytes 할당</span><br><span class="line">32 bytes 할당</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>실제로 8bytes를 기본으로 capacity로 할당하고 있으나, 그 이상으로 string의 size가 넘어갈 시에 32bytes로 재할당시키는 것을 볼 수 있다.</p><hr><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://en.cppreference.com/w/cpp/container/vector/capacity" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/container/vector/capacity</a></li><li><a href="https://en.cppreference.com/w/cpp/container/vector/size" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/container/vector/size</a></li></ol>]]></content:encoded>
      
      <comments>https://harnzzi.github.io/2020/04/19/std-vector%EC%97%90%EC%84%9C-size-capacity%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hello World using Hexo!</title>
      <link>https://harnzzi.github.io/2020/04/19/hello-world/</link>
      <guid>https://harnzzi.github.io/2020/04/19/hello-world/</guid>
      <pubDate>Sun, 19 Apr 2020 08:37:19 GMT</pubDate>
      <description>
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d -g <span class="comment"># hexo deploy --generate</span></span><br><span class="line">$ hexo g -d <span class="comment"># hexo generate --deploy</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure><h3 id="Posting"><a href="#Posting" class="headerlink" title="Posting"></a>Posting</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new post &lt;post_name&gt;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://harnzzi.github.io/2020/04/19/hello-world/#disqus_thread</comments>
    </item>
    
    <item>
      <title>BOJ::17825{주사위윷놀이};</title>
      <link>https://harnzzi.github.io/2020/04/17/BOJ-17825-%EC%A3%BC%EC%82%AC%EC%9C%84%EC%9C%B7%EB%86%80%EC%9D%B4/</link>
      <guid>https://harnzzi.github.io/2020/04/17/BOJ-17825-%EC%A3%BC%EC%82%AC%EC%9C%84%EC%9C%B7%EB%86%80%EC%9D%B4/</guid>
      <pubDate>Fri, 17 Apr 2020 13:25:52 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Infomation&quot;&gt;&lt;a href=&quot;#Infomation&quot; class=&quot;headerlink&quot; title=&quot;Infomation&quot;&gt;&lt;/a&gt;Infomation&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;처음에는 시작 칸에 말 4개가 있다.&lt;/li&gt;
&lt;li&gt;말은
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="Infomation"><a href="#Infomation" class="headerlink" title="Infomation"></a>Infomation</h1><ul><li>처음에는 시작 칸에 말 4개가 있다.</li><li>말은 게임판에 그려진 화살표의 방향대로만 이동할 수 있다. 말이 파란색 칸에서 이동을 시작하면 파란색 화살표를 타야 하고, 이동하는 도중이거나 파란색이 아닌 칸에서 이동을 시작하면 빨간색 화살표를 타야 한다. 말이 도착 칸으로 이동하면 주사위에 나온 수와 관계 없이 이동을 마친다.</li><li>게임은 10개의 턴으로 이루어진다. 매 턴마다 1부터 5까지 한 면에 하나씩 적혀있는 5면체 주사위를 굴리고, 도착 칸에 있지 않은 말을 하나 골라 주사위에 나온 수만큼 이동시킨다.</li><li>말이 이동을 마치는 칸에 다른 말이 있으면 그 말은 고를 수 없다. 단, 이동을 마치는 칸이 도착 칸이면 고를 수 있다</li><li>말이 이동을 마칠 때마다 칸에 적혀있는 수가 점수에 추가된다.</li></ul><h1 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h1><ul><li>입력받는 10개의 수는 주사위가 <strong>순서대로</strong> 주어지는 것이므로, 순서대로 주어지는 주사위 값을 4개의 말 중 하나와 대응하면 될 것이다. 모든 경우의 수는 4^10 = 1,048,576 번이므로, 시간복잡도가 높지만 문제가 될 것 같지 않다.</li><li>각 주사위 수에 말을 대입하면서 다음과 같은 경우에는 조합을 건너뛴다.<ol><li>현재의 말이 이미 도착한 경우</li><li>말이 이동을 완료한 후 위치에 다른 말이 존재할 경우</li></ol></li><li>조합이 완료되었다면, 점수를 그 전의 점수와 비교하여 더 큰 값으로 갱신한다.</li></ul><h1 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h1><ul><li>말의 구조체를 생성한다. 구조체에는 말이 현재 존재하고있는 위치와, 이미 도착 칸에 있는지에 대한 정보가 있어야 한다.</li><li>말판에 대한 배열이 생성되어야 한다. 말판이 blue일 때와 </li></ul>]]></content:encoded>
      
      <comments>https://harnzzi.github.io/2020/04/17/BOJ-17825-%EC%A3%BC%EC%82%AC%EC%9C%84%EC%9C%B7%EB%86%80%EC%9D%B4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Linux Kernel에 대하여...(수정중)</title>
      <link>https://harnzzi.github.io/2020/03/18/Linux-Kernel%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC/</link>
      <guid>https://harnzzi.github.io/2020/03/18/Linux-Kernel%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC/</guid>
      <pubDate>Wed, 18 Mar 2020 12:53:56 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;커널은 부팅 시에 시작되어 컴퓨터 종료시 커널이 끝난다. 장치 드라이버는 하드웨어와 밀접하게 연관되고 해당 장치를 제어하는 프로그램이다. 커널 공간에서 이루어지는 작업으로는 입출력, 네트워크 등의 하드웨어 제어, 메모리와 같은 컴퓨터의 리소스 관
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>커널은 부팅 시에 시작되어 컴퓨터 종료시 커널이 끝난다. 장치 드라이버는 하드웨어와 밀접하게 연관되고 해당 장치를 제어하는 프로그램이다. 커널 공간에서 이루어지는 작업으로는 입출력, 네트워크 등의 하드웨어 제어, 메모리와 같은 컴퓨터의 리소스 관리, 응용 프로그램의 실행 제어 등이 있다. 커널과는 달리 응용 프로그램은 사용자 요청에 의해 저장장치로부터 메모리에 로드되어 실행한다. 응용 프로그램이 하드웨어를 직접 제어할 수는 없기 때문에, 커널의 장치 드라이버를 사용하기 위해 시스템 호출 방법으로 커널에 접근하여 자료를 처리한다.</p><p>전자 제품에서 각각의 주변 기기들을 제어하기 위해 설계된 펌웨어 또한 장치 드라이버로 분류된다. 장치 드라이버의 실제 예는 소스가 공개된 리눅스 커널 소스에서 /driver 디렉터리 밑에 있는 파일들을 참조하여 볼 수 있다.</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><hr><ol><li><a href="https://ko.wikipedia.org/wiki/%EC%8B%9C%EC%8A%A4%ED%85%9C_%ED%98%B8%EC%B6%9C" target="_blank" rel="noopener">https://ko.wikipedia.org/wiki/%EC%8B%9C%EC%8A%A4%ED%85%9C_%ED%98%B8%EC%B6%9C</a></li></ol>]]></content:encoded>
      
      <comments>https://harnzzi.github.io/2020/03/18/Linux-Kernel%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC/#disqus_thread</comments>
    </item>
    
    <item>
      <title>RTOS와 GTOS &lt;스케쥴링&gt; 편</title>
      <link>https://harnzzi.github.io/2020/02/25/RTOS%EC%99%80-GTOS-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81-%ED%8E%B8/</link>
      <guid>https://harnzzi.github.io/2020/02/25/RTOS%EC%99%80-GTOS-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81-%ED%8E%B8/</guid>
      <pubDate>Mon, 24 Feb 2020 15:46:02 GMT</pubDate>
      <description>
      
        &lt;p&gt;RTOS(Real Time Operating System)과, 일반적으로 OS라고 불리우는 GPOS(General Purpose Operating System)에 대해서 알아봅니다.&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;RTOS&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;GPOS&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;우선순위 기반 스케쥴링&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;우선순위 보다는 스레드와 프로세스 모두 동일한 순서로 수행. 즉, &lt;strong&gt;높은 스루풋을 기준&lt;/strong&gt;으로 처리&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;프로그램이 실행되는 시간이 중요한 시스템에 적합&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;동시에 많은 응용 프로그램을 실행하기에 좋음. 우선순위가 높은 하나의 작업을 해야하는 프로세스가 있다고 하더라도, 우선순위가 낮은 여러개의 작업을 먼저 수행할 수 있음(preemptive/non-preemptive)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;항상 우선순위를 기반으로 하고(preemptive), 우선순위가 높은 프로세스를 실행할 때 동안 낮은 우선순위를 가진 프로세스는 실행되지 않음&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;OS는 스케쥴링된 스레드가 많을수록 latency가 생길 수 있는데, RTOS의 경우 프로세스와 스레드가 모두 지정된 시간 제한 내에 실행되어야 하기 때문에 latency가 없음&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>RTOS(Real Time Operating System)과, 일반적으로 OS라고 불리우는 GPOS(General Purpose Operating System)에 대해서 알아봅니다.<br><br></p><hr><table><thead><tr><th align="center">RTOS</th><th align="center">GPOS</th></tr></thead><tbody><tr><td align="center">우선순위 기반 스케쥴링</td><td align="center">우선순위 보다는 스레드와 프로세스 모두 동일한 순서로 수행. 즉, <strong>높은 스루풋을 기준</strong>으로 처리</td></tr><tr><td align="center">프로그램이 실행되는 시간이 중요한 시스템에 적합</td><td align="center">동시에 많은 응용 프로그램을 실행하기에 좋음. 우선순위가 높은 하나의 작업을 해야하는 프로세스가 있다고 하더라도, 우선순위가 낮은 여러개의 작업을 먼저 수행할 수 있음(preemptive/non-preemptive)</td></tr><tr><td align="center">항상 우선순위를 기반으로 하고(preemptive), 우선순위가 높은 프로세스를 실행할 때 동안 낮은 우선순위를 가진 프로세스는 실행되지 않음</td><td align="center"></td></tr><tr><td align="center">OS는 스케쥴링된 스레드가 많을수록 latency가 생길 수 있는데, RTOS의 경우 프로세스와 스레드가 모두 지정된 시간 제한 내에 실행되어야 하기 때문에 latency가 없음</td><td align="center"></td></tr></tbody></table><a id="more"></a><p><br><br></p><h1 id="Foreground-Background-system"><a href="#Foreground-Background-system" class="headerlink" title="Foreground/Background system"></a>Foreground/Background system</h1><hr><p> 복잡도가 낮은 소형 시스템은 일반적으로 전경/배경 시스템, 또는 super-loop로 설계됩니다.</p><p> super-loop는 각 모듈을 호출하여 원하는 작업(함수)을 수행하는 무한루프(while(1))로 구성되어 있으며, 이것을 배경(Background) 시스템이라 부릅니다. 인터럽트 서비스 루틴(ISR)은 비동기 이벤트들(Foreground)를 처리합니다. 즉, Background에서 작업을 수행하다가 꼭 필요한 시기에 우선순위가 높은 작업을 수행해 주어야 한다면 Foreground; ISR(Interrupt Service Routine)를 처리하게 됩니다.</p><p><img src="https://raw.githubusercontent.com/harnzzi/images/master/image2019-10-8_0-30-32.png" alt="background"></p><p> 따라서 위의 그림과 같이, Background가 작업을 수행하다가 인터럽트가 걸리게 되면 멈추고 인터럽트부터 처리합니다(꼭!). 그 이후에야 Background로 복귀가 가능합니다.</p><br><h2 id="Pros-and-Cons"><a href="#Pros-and-Cons" class="headerlink" title="Pros and Cons"></a>Pros and Cons</h2><ol><li>간단한 프로그램 짜기에 용이합니다.</li><li>커널에 의한 메모리손실이나 수행시간 손실이 없습니다.</li><li>모든 함수는 우선순위가 같기 때문에, 프로그래머 자신이 순서대로 잘 돌 수 있도록 코드를 짜는 것이 중요합니다.</li></ol><p><br><br></p><h1 id="Real-Time-Kernel-System"><a href="#Real-Time-Kernel-System" class="headerlink" title="Real-Time Kernel System"></a>Real-Time Kernel System</h1><hr><p> 커널기반의 프로그램을 이용하면 위의 Background/Foreground system과 다음과 같은 차이점이 존재합니다.</p><ol><li>커널을 사용하게 되면, 2.5%정도의 시간을 더 허비하게 됩니다</li><li>커널 사용시 ROM, RAM을 더 많이 사용하게 됩니다.</li><li>Real-Time Kernel은 MCU의 수행 시간을 컨트롤합니다. 즉, 제일 우선순위가 높은 것 부터 처리할 수 있습니다.</li><li>한 프로그램에 여러개의 Task가 존재합니다. (즉, 무한루프가 여러개 존재합니다.)</li><li>각각의 Task들은 자기 자신이 온전히 CPU를 독점하여 사용하는 것 처럼 동작합니다.</li></ol><p><img src="https://raw.githubusercontent.com/harnzzi/images/master/image2019-10-8_1-3-44.png" alt="kernel1"></p><p>(1) 우선 순위가 낮은 작업이 실행 중입니다.</p><p>(2) 인터럽트가 발생하면, CPU는 인터럽트 서비스를 담당하는 ISR로 벡터(Array);다수의 데이터를 처리하는 명령어를 가진 CPU ㅡ 를 보냅니다.</p><p>(3) ISR은 인터럽트 장치를 서비스 하지만 실제로는 거의 작동하지 않습니다. ISR은 일반적으로 높은 우선 순위를 가진 작업에 신호를 보내거나 메시지를 보냅니다. </p><p>(4) ISR이 완료되면 높은 우선순위를 가진 Task를 수행 할 준비가 되었으며, 그 전 중단된 낮은 우선순위의 작업으로 돌아가지 않고 대신 더 중요한 작업으로 Context Switch됩니다.</p><p>(5) 우선 순위가 높은 작업은 인터럽트에 응답하여 필요한 처리를 실행하고 수행합니다.</p><p>(6) 우선순위가 높은 작업이 완료되면 Task의 시작 부분으로 돌아갑니다.</p><p>(7) 낮은 우선순위를 갖고 있던 작업은 인터럽트 되었던 지점에서부터 정확하게 다시 시작합니다.</p><p> 즉, Background/Foreground System은 모든 일을 수행하는 순서와 끝내는 시간, 그 종류 등을 모두 직접 계산하고 결정해야 합니다. 하지만 Kernel System을 이용하면 해야할 작업의 우선순위를 지정한다면 그것을 알아서 진행시킬 수 있다는 이점이 있습니다.</p><p><br><br></p><h1 id="Context-Switching"><a href="#Context-Switching" class="headerlink" title="Context Switching"></a>Context Switching</h1><hr><p> 커널의 스케쥴러가 각 Task를 수행하는 작업을 하게 됩니다. 이 때 원칙에 따라 커널의 종류가 선점형(preemptive)과 비선점형(non-preemptive)로 나뉘게 됩니다. </p><p> 이 때 Context Switching이 빠른 커널이 꼭 장점만 있는 것은 아닙니다. 왜냐하면, CPU가 가지고 있는 레지스터의 양에 따라서 부과되는 오버헤드의 양이 달라지기 때문입니다. 즉, Context Switching이 Kernel Dependent하면서도 CPU Dependent하므로 이것만으로 커널의 성능을 결정 지을 수는 없게 됩니다.</p><p> 또한 각각의 Task들은 선언되어 컴파일 되는 순간 스택에 자신의 공간을 갖습니다. 이 때 레지스터 정보를 스택에 Push하고, 수행할 Task의 레지스터 정보를 Pop하여 일을 수행합니다. 이후에 Context Switching을 해야할 때 다시 현재의 레지스터 정보를 스택에 저장하고, 빼내어 수행하는 일을 매우 빠르고 효율적으로 수행하면서 멀티 태스킹을 하게 됩니다.</p><p><br><br></p><h1 id="Non-preemptive-v-s-Preemptive"><a href="#Non-preemptive-v-s-Preemptive" class="headerlink" title="Non-preemptive v.s Preemptive"></a>Non-preemptive v.s Preemptive</h1><hr><p> 비선점형 커널은 ISR로 바로 넘겨주기 전에 돌고 있던 Task로 다시 CPU 점유권을 넘기는 커널입니다. 따라서 아무리 우선순위가 높은 Task가 점유하고자 해도 현재 작업을 수행하고 있는 Task에게 CPU 점유권이 주어집니다. 따라서 이러한 커널은 멀티태스킹을 하기 위해서, Task가 자체적으로 자신의 CPU 점유권을 놓아야 합니다. ex) OS_Dly_wait(100)…</p><p><img src="https://raw.githubusercontent.com/harnzzi/images/master/image2019-10-8_10-51-58.png" alt="non-preemp"></p><p> 따라서 다음과 같은 특징이 존재하게 됩니다.</p><ol><li>인터럽트의 지연시간이 짧습니다(응답시간과 복귀시간이 짧아지게 됩니다).</li><li>Task레벨에서도 비재진입 함수를 사용할 수 있게 됩니다(Task에서 제어권을 넘겨주기 전에는 절대로 다른 Task로 제어권이 넘어가지 않기 때문).</li><li>Task의 응답성이 떨어집니다(수행시간이 긴 Task가 점유하게 된다면, 우선순위가 높은 Task가 오랜시간 동안 대기해야 될 가능성).</li></ol><p><img src="https://raw.githubusercontent.com/harnzzi/images/master/image2019-10-8_11-16-38.png" alt="preemp"></p><p> 선점형 커널은 이와 반대로, ISR에서 복귀할 때 최 우선순위를 갖는 Task에게 CPU 점유율을 넘기게 됩니다. 따라서 로직이 조금 더 복잡하지만, 프로그램의 응답성이 매우 개선됩니다.</p><p> 선점형 커널에서는 최상위 우선순위 Task가 언제 CPU를 받을 수 있을지 알 수 있게 되는데, 그로 인하여 Critical Section, 비재진입 함수의 사용 등에서 문제가 발생하게 됩니다. 아직 Task의 작업이 끝나지 않은 상태에서 더 중요한 Task에 CPU 점유권이 넘어갔는데 비재진입 함수를 호출한다면 데이터가 꼬이게 될 가능성이 존재하게 됩니다(전역변수, …). 따라서 상호 배제적으로 공유자원에 접근하기 위한 방법이 필요하게 됩니다. </p><p> 그 방법은 다음과 같습니다.</p><ol><li>인터럽트 enable/disable</li><li>Semaphore의 사용</li><li>TAS(Test and Set)</li><li>Scheduler Lock/Unlcok</li></ol><p><br><br></p><h1 id="Clock-Tick-Jitter"><a href="#Clock-Tick-Jitter" class="headerlink" title="Clock Tick, Jitter"></a>Clock Tick, Jitter</h1><hr><p> Clock Tick이란 정기적으로 일어나는 특별한 인터럽트입니다. Clock Tick을 통하여  CPU의 점유권을 스케쥴러에게 양도하고, 지정한 틱이 지나면 Ready List에 들어가게 됩니다.</p><p><img src="https://raw.githubusercontent.com/harnzzi/images/master/image2019-10-8_13-24-10.png" alt="clock,jitter"></p><p> 하지만 위와 같이 높은 우선순위의 Task와 ISR이 1틱(20ms)만큼 딜레이 하려는 Task보다 선행되어 실행되는 경우, 실제로는 불규칙적인 간격을 보이게 됩니다. 이러한 현상을 Jitter라고 합니다. 따라서 Jitter현상은 Hard Real-Time OS에서 조금 덜한 현상을 보입니다.</p><p><br><br></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><hr><ol><li><a href="https://doc.micrium.com/" target="_blank" rel="noopener">https://doc.micrium.com/</a></li><li><a href="http://www.circuitstoday.com/gpos-versus-rtos-for-an-embedded-system" target="_blank" rel="noopener">http://www.circuitstoday.com/gpos-versus-rtos-for-an-embedded-system</a></li><li>‘Operating Systems : Three Easy Pieces’, Remzi H. Arpaci-Dusseau, Andrea C. Arpaci-dusseau</li></ol>]]></content:encoded>
      
      <comments>https://harnzzi.github.io/2020/02/25/RTOS%EC%99%80-GTOS-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81-%ED%8E%B8/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
